import 'module:std' as std
import 'module:spotube_plugin' as spotube
import { TOTP, OTPAlgorithm } from '../../dependencies/hetu_otp_util/lib/assets/hetu/otp_util.ht';

var StreamController = std.StreamController
var Stream = std.Stream
var StreamSubscription = std.StreamSubscription
var DateTime = std.DateTime
var Duration = std.Duration
var HttpClient = std.HttpClient
var HttpResponse = std.HttpResponse
var RequestOptions = std.RequestOptions
var Timer = std.Timer
var JSON = std.JSON
var Regex = std.Regex
var LocalStorage = spotube.LocalStorage
var Webview = spotube.Webview
var Cookie = spotube.Cookie

class SpotifyAuthEndpoint {
  final controller: StreamController
  var _timer: Timer
  /// Map of:
  /// - `cookies`: Map of cookies from <Cookie>.toJson()
  /// - `accessToken`: The access token string
  /// - `expiration`: The expiration timestamp in milliseconds since epoch
  var credentials: Map
  var client: HttpClient

  get authStateStream -> Stream => controller.stream

  construct (onEvent: (data) -> void){
    controller = StreamController.broadcast()
    client = HttpClient()

    controller.stream.listen((event) {
      if(onEvent != null) {
        onEvent(event)
      }
      if(event["type"] == "recovered" || event["type"] == "login") {
        _timer?.cancel()
        _timer = Timer.periodic(getExpirationDuration(), (cancel){
          refreshCredentials()
        })
      }
    })

    initializeFromLocalStorage()
  }

  fun isExpired() -> bool {
		if (credentials == null) {
			return true
		}

		final currentTime = DateTime.now()

		final expirationTime = DateTime.fromMillisecondsSinceEpoch(credentials["expiration"])

		return currentTime.isAfter(expirationTime)
	}

  fun getExpirationDuration() -> Duration {
		if (credentials == null) {
			return 0;
		}

		final currentTime = DateTime.now()

		final expirationTime = DateTime.fromMillisecondsSinceEpoch(credentials["expiration"])

		return expirationTime.difference(currentTime)
	}


  fun initializeFromLocalStorage() {
		LocalStorage.getString("credentials").then((credentialsStr){
      if (credentialsStr != null) {
        credentials = JSON.decode(credentialsStr);
        if (isExpired()) {
          refreshCredentials()
        } else {
          controller.add({ type: "recovered" }.toJson())
        }
      }
    })
	}

  fun getLatestNuance() -> Future { // Future<{v: int, s: string}>
    return client.get_req(
      "https://codeberg.org/sonic-liberation/blubber-junkyard-elitism/raw/branch/main/nuances.json"
    ).then((res) {
      var data = JSON.decode(res.data);
      data.sort((a, b) => b["v"].compareTo(a["v"]))
      return data.first
    })
  }

  fun generateTimedOnTimePassword(secret: string) -> Future {
		return client.get_req("https://open.spotify.com/api/server-time")
    .then((res) {
      final timestampSeconds = res.data["serverTime"]

      final totp = TOTP(
        secret: secret,
        algorithm: OTPAlgorithm.SHA1,
        digits: 6,
        interval: 30,
      )

      return totp.value(
        date: DateTime.fromMillisecondsSinceEpoch(
          timestampSeconds * 1000 // Convert seconds to milliseconds
        )
      )
    })
	}

  fun randomBytesFromMath(length: int) -> string {
    var bytes = List()

    for (int i = 0; i < length; i++) {
      bytes.add(Random().nextInt(256).toString())
    }
  }

  fun getToken({
		mode = "transport",
		timestamp: DateTime,
		totp: string,
		spDc: string,
    mode: string,
    totpVer: int
	}) -> Future {
    print("Timestamp: ${timestamp}, TOTP: ${totp}, Mode: ${mode}, spDc: ${spDc}")
    final timestampSeconds = (timestamp.millisecondsSinceEpoch / 1000).floor()
		final accessTokenUrl = "https://open.spotify.com/api/token?reason=${mode}&productType=web-player&totp=${totp}&totpServer=${totp}&totpVer=${totpVer}"

		final userAgent = "${DateTime.now().millisecondsSinceEpoch}${Random().nextInt(100) * 1000}${randomBytesFromMath(16)}"
    .split("").join("")

		return client.get_req(
      accessTokenUrl, 
      options: RequestOptions(
        headers: {
          Cookie: spDc ?? "",
          "User-Agent": userAgent,
        }.toJson(),
      )
    ).then((res){
      return { body: res.data, headers: res.headers }
    })
	}

  fun credentialsFromCookie(cookies: List) -> Future {
		final spDc = cookies.where((c) => c["name"] == "sp_dc").first?["value"];

    return getLatestNuance().then((nuance){
      return generateTimedOnTimePassword(nuance["s"]).then((totp){
        return getToken(
          totp: totp,
          timestamp: DateTime.now(),
          spDc: "sp_dc=${spDc};",
          mode: "transport",
          totpVer: nuance["v"],
        ).then((res){
          if (res.body["accessToken"] == null) {
            print(
              "The access token is only ${res.body["accessToken"]?.length} characters long instead of 374. Your authentication probably doesn't work",
            );
          }

          return {
            cookies: cookies,
            accessToken: res.body["accessToken"],
            expiration: res.body["accessTokenExpirationTimestampMs"],
          }
        })
      })
    })
	}
  
  fun isAuthenticated() -> bool {
    return credentials != null && !isExpired()
  }
  
  fun login(cookies: List) -> Future {
		return this.credentialsFromCookie(cookies).then((creds){
      LocalStorage.setString("credentials", JSON.encode(creds.toJson()));
      credentials = creds;

      controller.add({type: "login"}.toJson());
    })
	}

	fun refreshCredentials() -> Future {
		// Se for token pessoal, usar refresh token
		if (credentials["isPersonalToken"] == true) {
			return refreshPersonalToken();
		}
		
		// Se for autenticação por cookie, usar método original
		if (credentials["cookies"] == null) {
			print(
				"[refreshCredentials] No cookie found. Cannot refresh credentials.",
			);
			return;
		}
		return this.credentialsFromCookie(credentials["cookies"]).then((creds){
      LocalStorage.setString("credentials", JSON.encode(creds.toJson()));
      credentials = creds;
      controller.add({ type: "refreshed" }.toJson())
    })
	}

  fun authenticate() -> Future {
    var webview = Webview(uri: "https://accounts.spotify.com/")

    var sub: StreamSubscription = webview.onUrlRequestStream.listen((url){
      var safeUrl = url.endsWith("/") ? url.substring(0, url.length - 1) : url
      var exp = Regex("https:\\/\\/accounts.spotify.com\\/.+\\/status")
      if(exp.hasMatch(safeUrl)) {
        return webview.getCookies(url).then((cookies){
          return login(cookies.map((cookie)=> cookie.toJson()).toList()).then(() {
            return webview.close()
          })
        })
      }
    })

    return webview.open()
  }

  fun logout() {
		credentials = null;
		LocalStorage.remove("credentials");
		controller.add({type: "logout"}.toJson());
	}

  /// Método para usar token pessoal do Spotify Web API
  fun setPersonalToken(accessToken: string, refreshToken: string = null, clientId: string = null, clientSecret: string = null) -> Future {
    final personalCredentials = {
      accessToken: accessToken,
      refreshToken: refreshToken,
      clientId: clientId,
      clientSecret: clientSecret,
      expiration: DateTime.now().add(Duration(hours: 1)).millisecondsSinceEpoch,
      isPersonalToken: true
    }
    
    LocalStorage.setString("credentials", JSON.encode(personalCredentials.toJson()));
    credentials = personalCredentials;
    
    // Configurar renovação automática para tokens pessoais
    _timer?.cancel()
    _timer = Timer.periodic(Duration(minutes: 50), (cancel) {
      refreshPersonalToken()
    })
    
    controller.add({type: "login"}.toJson());
  }

  /// Método para renovar token pessoal
  fun refreshPersonalToken() -> Future {
    // Se tem refresh token, usar refresh token flow
    if (credentials["refreshToken"] != null) {
      return client.post_req(
        "https://accounts.spotify.com/api/token",
        data: {
          "grant_type": "refresh_token",
          "refresh_token": credentials["refreshToken"]
        }.toJson(),
        options: RequestOptions(
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          }.toJson()
        )
      ).then((res) {
        final newCredentials = {
          accessToken: res.data["access_token"],
          refreshToken: res.data["refresh_token"] ?? credentials["refreshToken"],
          clientId: credentials["clientId"],
          clientSecret: credentials["clientSecret"],
          expiration: DateTime.now().add(Duration(seconds: res.data["expires_in"])).millisecondsSinceEpoch,
          isPersonalToken: true
        }
        
        LocalStorage.setString("credentials", JSON.encode(newCredentials.toJson()));
        credentials = newCredentials;
        
        print("[refreshPersonalToken] Token renovado com refresh token");
        controller.add({type: "refreshed"}.toJson());
      })
    }
    // Se tem client credentials, usar client credentials flow
    else if (credentials["clientId"] != null && credentials["clientSecret"] != null) {
      return client.post_req(
        "https://accounts.spotify.com/api/token",
        data: {
          "grant_type": "client_credentials",
          "client_id": credentials["clientId"],
          "client_secret": credentials["clientSecret"]
        }.toJson(),
        options: RequestOptions(
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          }.toJson()
        )
      ).then((res) {
        final newCredentials = {
          accessToken: res.data["access_token"],
          refreshToken: credentials["refreshToken"],
          clientId: credentials["clientId"],
          clientSecret: credentials["clientSecret"],
          expiration: DateTime.now().add(Duration(seconds: res.data["expires_in"])).millisecondsSinceEpoch,
          isPersonalToken: true
        }
        
        LocalStorage.setString("credentials", JSON.encode(newCredentials.toJson()));
        credentials = newCredentials;
        
        print("[refreshPersonalToken] Token renovado com client credentials");
        controller.add({type: "refreshed"}.toJson());
      })
    }
    else {
      print("[refreshPersonalToken] Não é possível renovar: faltam credenciais");
      return;
    }
  }
}

export { SpotifyAuthEndpoint }